### 1.js数据类型，新增数据类型set，map的用法与数据结构，weakmap，weakset
[(1条消息) js的数据类型、堆栈存储、多数据类型计算_star@星空的博客-CSDN博客](https://blog.csdn.net/weixin_43638968/article/details/107588961)
- 最重要的区别是，WeakMap 不会阻止在没有对键的引用时对键进行**垃圾收集**。
1、WeakMap只接受对象作为key，如果设置其他类型的数据作为key，会报错。
2、WeakMap的key所引用的对象都是弱引用，只要对象的其他引用被删除，垃圾回收机制就会释放该对象占用的内存，从而避免内存泄漏。
3、由于WeakMap的成员随时可能被垃圾回收机制回收，成员的数量不稳定，所以没有size属性。
4、没有clear()方法/map有
5、不能遍历/map有forEach，keys，entries

### 2.object.keys；Symbol 作为属性名
[js遍历对象篇（一）-for...in和Object.keys - 掘金 (juejin.cn)](https://juejin.cn/post/6961956292827021349)
1. 返回一个所有元素为字符串的数组，其元素来自给定的 `object` 上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。
2. 如果你想获取一个对象的所有属性，甚至包括不可枚举的，请查看 [`Object.getOwnPropertyNames`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)。
3. 在 ES5 里，如果此方法的参数不是对象（而是一个原始值），那么它会抛出 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)。 在 ES2015 中，非对象的参数将被强制转换为一个对象。
4. js中原型属性一般是不可枚举的，而自定义的属性一般是可枚举的可以通过`propertylsEnumerable()`方法判断该属性是否可枚举
5. ！！！Symbol 作为属性名，遍历对象的时候，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`（包括不可枚举属性）、`JSON.stringify()`返回
6. `Object.getOwnPropertySymbols()`在给定对象自身上找到的所有 Symbol 属性的数组，可获取自身所有Symbol属性，包括不可枚举的Symbol属性
7. `Reflect.ownKeys()` 方法返回一个由目标对象自身的属性键组成的数组。它的返回值相等于`Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))`

枚举:1. 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。

### 3.定义函数常用的方式
1. 命名函数/自定义函数/函数声明
2. 函数表达式/匿名函数
3. new Function（）{}
4. 区别：函数声明会在预解析的时候进行函数提升

### 4. DOM事件的绑定与优化？？
[(3条消息) js中事件委托_star@星空的博客-CSDN博客](https://blog.csdn.net/weixin_43638968/article/details/108518584)
绑定很多的点击事件，删除所有点击事件，内存
1. 事件代理/事件委托：指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。
2. 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能
3. 实现方法：
	- 这样我们就可以做到很多个a链接上的点击事件都添加到父元素div上。
	- 当然还要排除掉不参加事件委托的子元素。/选择参加的元素
4. 应用场景：vue
	- 我们经常遇到vue中`v-for`一个列表，列表的每一项都绑定了`@click`处理事件。我们都知道绑定这么多监听，从性能方面来说是不太好的。那我们我们可以通过把每个item的click事件委托给父元素的形式来实现。
5. 解绑事件
	1. 传统方式删除事件 `eventTarget.onclick = null;`
	2. 方法[监听](https://so.csdn.net/so/search?q=%E7%9B%91%E5%90%AC&spm=1001.2101.3001.7020)注册方式删除（addEventListener注册的事件删除） ` eventTarget.removeEventListener(type, listener[, useCapture])`
	3. attachEvent注册的事件删除 `eventTarget.detachEvent(‘onclick’, fn);`
 [(3条消息) 删除事件（解绑事件）（三种方式）_~嘘~禁止想象~的博客-CSDN博客_删除事件](https://blog.csdn.net/weixin_45773503/article/details/106005237?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166496272016782428696359%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166496272016782428696359&biz_id=0&spm=1018.2226.3001.4187)


### 5. 水平垂直居中
1. flex布局
2. absolute+transfrom:translate
3. absolute+定位全为0+margin：auto；
4. 行内元素
```css
.father {
text-align:center;
}
.son {
vertical-align:middle;
line-height:inherit;
}
```

### 6.单页面应用，后端数据变化后，主动通知前端？？？？
[(3条消息) 新手入门：websocket_一只BOY猿的博客-CSDN博客_websocket](https://blog.csdn.net/qq_32109909/article/details/109738197?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166496394816782428660638%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166496394816782428660638&biz_id=0&spm=1018.2226.3001.4187)
1. 后端通知前端：（服务端定时推送）WebSocket 
	[webSocket(一) 浅析 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903950659878925)
	1. 建立在tcp协议上，与http兼容性良好；
	2. 纯事件驱动，一旦连接建立，通过监听事件可以处理到来的数据和改变的连接状态；一旦连接建立，通过监听事件可以处理到来的数据和改变的连接状态
	3. 没有同源限制
	4. 不用频繁创建及销毁 TCP 请求，减少网络带宽资源的占用，同时也节省服务器资源;
	5. 无超时处理
1. 前端轮询后端：
	1. 短轮询：短轮询(Polling)的实现思路就是浏览器端每隔几秒钟向服务器端发送http请求，服务端在收到请求后，不论是否有数据更新，都直接进行响应。在服务端响应完成，就会关闭这个Tcp连接（非常消耗资源）
	2. 长轮询：客户端发送请求后服务器端不会立即返回数据，服务器端会阻塞请求连接不会立即断开，直到服务器端有数据更新或者是连接超时才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据。（有数据、连接超时后，服务端才会返回）
	[webSocket(二) 短轮询、长轮询、Websocket、sse - 掘金 (juejin.cn)](https://juejin.cn/post/6844903955240058893)
### 7.js垃圾回收机制
[(3条消息) 一文彻底搞懂js垃圾回收和内存泄露_star@星空的博客-CSDN博客](https://blog.csdn.net/weixin_43638968/article/details/109492727)
垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。
1. 只有函数内的变量才可能被回收
2. 标记清除
	- js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。
	- 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
3. 引用计数
	- 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。
```JS
function test() {
    var a = {};    // a指向对象的引用次数为1
    var b = a;     // a指向对象的引用次数加1，为2
    var c = a;     // a指向对象的引用次数再加1，为3
    var b = {};    // a指向对象的引用次数减1，为2
}

```
#### 内存泄漏
- 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。
##### vue中的内存泄漏
1. mounted/created 钩子中使用js绑定了DOM/BOM，第三方库的初始化，就要在beforeDestroy中解绑，销毁；
2. 组件中使用了setInterval，就要在beforeDestroy中销毁；
##### js中的内存泄漏
1. 循环引用：：一个DOM对象被一个Javascript对象引用，与此同时又引用同一个或其它的Javascript对象，这个DOM对象可能会引发内存泄露。这个DOM对象的引用将不会在脚本停止的时候被垃圾回收器回收。要想破坏循环引用，引用DOM元素的对象或DOM对象的引用需要被赋值为null。
2. 闭包
3. DOM泄漏：当原有的DOM被移除时，子结点引用没有被移除则无法回收。、
4. 定时器：定时器setInterval或者setTimeout在不需要使用的时候，没有被clear，导致定时器的回调函数及其内部依赖的变量都不能被回收，这就会造成内存泄漏。
    解决方式：当不需要interval或者timeout的时候，调用clearInterval或者clearTimeout

### 8.跨域？新方法
[(3条消息) 如何实现跨域？_star@星空的博客-CSDN博客_如何跨域](https://blog.csdn.net/weixin_43638968/article/details/108283066)
1. jsonp :只能针对get
2. cors  `res.header('Access-Control-Allow-Origin', 'http://example.com');`
3. Nginx 
	1. 反向代理：即所有客户端的请求都必须先经过的处理，nginx作为代理服务器再讲请求转发给node或者java服务，这样就规避了同源策略。
			https://juejin.cn/post/7082655545491980301 【nginx】
			[聊聊代理服务器的那些事 - 掘金 (juejin.cn)](https://juejin.cn/post/7147506835594543118)
		-   正向代理代理客户端请求，隐藏真实的客户端
		-   反向代理代理服务器请求，隐藏真实的服务器
### 9.vue2响应式，Object.defineProperty()???
[[vue3快速上手#vue2 x的响应式]]
#### 1.Object.defineProperty()
看笔记或者文档
[Object.defineProperty() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)
- **`Object.defineProperty()`** 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
- `Object.defineProperty(obj, prop, descriptor)` 要定义的对象，属性，描述
- descriptor对象：value，enumberable,writable,configurable,get(),set()

#### 2. vue2响应式原理
看笔记
1. 监视data中所有层次的数据
2. 对象新增属性，直接检测不到，需要用`vm.$set(obj,prop,value)` `Vue.set()`
3. 数组：包裹数组更新元素的方法；返回新数组，代替旧数组

### 10.vue3 响应式，proxy
[[vue3快速上手#4 Vue3 0中的响应式原理]]
### 11.webpack 更改配置？？？
1. vue.config.js 配置proxy跨域
