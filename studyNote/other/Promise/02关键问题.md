# Promise 的几个关键问题

##### 1. 如何改变 Promise 的状态？
- `resolve(value)`：如果当前是 pending 就会变为 resolved
- `reject(reason)`：如果当前是 pending 就会变为 rejected
- 抛出异常：如果当前是 pending 就会变为 rejected

##### 2. 一个promise指定多个成功/失败回调函数，都会调用吗?
当 promise 改变为对应状态时都会调用。

```js
let p = new Promise((resolve, reject) => {
  throw 100
})
p.then(
  value => { },
  reason => {
    console.log('reason1 ' + reason)
  }
)
p.then(
  value => { },
  reason => {
    console.log('reason2 ' + reason)
  }
)
// 输出
// reason1 100
// reason2 100
```

##### 3. 改变 promise 状态和指定回调函数谁先谁后？
1. 都有可能（异步任务一般先指定回调，再改变状态）
2. 如何先改状态再指定回调?
    - 在执行器中直接调用 `resolve()/reject()`
    - 延迟更长时间才调用 `then()`
3. 什么时候才能得到数据（回调函数何时zhi'xing）?
    - 如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据
    - 如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据

```js
// 先指定回调，再改变状态（比如：存在异步任务）
const p2 = new Promise((resolve, reject) => {
  // setTimeout 第三个参数，该参数将传入第一个函数参数
  setTimeout(resolve, 1000, '成功的数据') // 后改变数据，同时传入值
}).then(
  // 先指定回调函数，保存当前回调函数
  value => {
    console.log(value)
  }
)

// 先改状态，在指定回调函数
const p1 = new Promise((resolve, reject) => {
  resolve(100) // 先改变数据，同时传入值
}).then(
  // 后指定回调函数，异步执行回调函数
  value => {
    console.log(value)
  }
)
```
> [!TIP]
> 注意：new Promise(executor) 中的执行器以及 `.then`、`.catch` 都是同步的，但是执行器中的异步操作是异步的，`.then` 和 `.catch` 中的回调函数也是异步的。

#### 4. promise.then() 返回的新promise 的结果状态由什么决定？

- 简单表达：由 `then()` 指定的回调函数执行的结果决定
- 详细表达：
  1. 如果抛出异常，新 promise 变为 `rejected`, reason为抛出的异常
  2. 如果返回的是非 promise 的任意值，新promise变为 `resolved`，value 为返回的值
  3. 如果返回的是另一个新 promise，此 promise 的结果就会成为新 promise 的结果

#### 5. promise 如何串连多个操作任务? #important 

- promise的 `then()` 返回一个新的 promise，可以看成 `then()` 的链式调用
- 通过 `then` 的 **链式调用串连多个同步/异步任务**

> [!TIP]
> `.then()` 中可以处理同步任务，也可以处理异步任务。处理异步任务时需要新创建一个 `Promise`。 

```js
// 任务1
const p = new Promise((resolve, reject) => {
  setTimeout(()=>{
  resolve('ok');
  },1000)
});
p.then(value => { 
    return new Promise((resolve, reject) => {
    resolve('success');
}).then(value => { 
	console.log(value);//success
}).then(value => { 
	console.log(value);//成功状态的undefined值
	//这个then()对应的promise对象没有返回值,undefined
});

```

#### 6. 异常传透

当使用 promise 的 then 链式调用链时，可以在最后指定失败的回调

```js
new Promise((resolve, reject) => {
    resolve('ok');
    // reject(1);//这里的失败，由最后的catch方法处理
}).then(value => {
    console.log(value)//ok
}).then(value => {
    console.log(value)//undefined
}).catch(reason => {
  console.warn('异常：' + reason)////异常：1
})
```

注意：
- `.catch` 所谓的异常穿透并不是一次失败状态就触发 `catch`，而是一层一层的传递下来的
- 异常穿透的前提条件是所有的 `.then` 都没有指定失败状态的回调函数。
- 如果 `.catch` 前的所有 `.then` 都指定了失败状态的回调函数，`.catch` 就失去了意义。

##### 值传透（扩展）

值穿透指的是，链式调用的参数不是函数时，会发生值穿透，就传入的非函数值忽略，传入的是之前的函数参数。

```js
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log) // 1
```

只有传入的是函数才会传递给下一个链式调用。
```js
Promise.resolve(1)
  .then(2)
  .then(() => 3)
  .then(4)
  .then(console.log) // 3
```

```js
Promise.resolve(1)
  .then(function () {
    return 2
  })
  .then(() => { Promise.resolve(3) }) // 没有返回值，默认 undefined
  .then(4)
  .then(console.log) // undefined
```

#### 7. 中断 Promise 链

- 什么是中断：当使用 promise 的 `then` 链式调用时，在中间中断，不再调用后面的回调函数
- 中断的方法(唯一)：在回调函数中返回一个 `pendding` 状态的 promise 对象
%% `pendding` 状态的 promise 对象的then（）无法执行%%
如何返回一个 `pendding` 状态的 promise 对象：
```js
return new Promise(() => { }) // pending
```
或者使用 `Promise.race([])`，`race` 方法接收一个空的可迭代对象时，该 Promise 会一直处于 `pendding` 状态。
```js
return Promise.race([]) // pending
```

中断之前：
```js
Promise.resolve(1)
  .then(value => {
    console.log(value) // 1
  }) // 下面都会打印
  .then(value => console.log(value)) // undefined
  .then(value => console.log(value)) // undefined
```

中断之后：
```js
Promise.resolve(1)
  .then(value => {
    console.log(value) // 1
    // 返回一个 pending 状态的 promise 来中断这个调用链
    return new Promise(() => { })
    // 或者：return Promise.race([])
  }) // 下面都不会打印
  .then(value => console.log(value))
  .then(value => console.log(value))
```

