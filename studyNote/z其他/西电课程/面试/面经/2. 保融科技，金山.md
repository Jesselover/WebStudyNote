# 1.保融科技
### 1.for in ，for of, forEach
[(3条消息) 比较for、for...in、for...of、forEach的区别_THER1881的博客-CSDN博客_foreach和forof区别](https://blog.csdn.net/thwr1881/article/details/124988134?spm=1001.2101.3001.6650.1&depth_1-utm_relevant_index=2)
1. for...in取key(object中可以取到原型链上的属性)，for...of取value(数组常用，遍历普通对象会报错)，forEach遍历数组
2. break，continue，return
	1. for 语句性能最好；能响应break, continue, return控制循环。
	2. forEach 无法响应break, continue, return控制循环。
	3. for in 无法响应break, continue, return控制循环；for in 主要针对对象，它不仅会循环对象本身的属性，还会查找循环原型上的属性；循环的顺序不确定。
	4. for of 能响应break, continue, return控制循环，还能遍历map、set 等类数组，但是不能循环普通的对象

### 2.vue2,vue3区别
[(3条消息) vue2与vue3的区别_star@星空的博客-CSDN博客_vue2 vue3](https://blog.csdn.net/weixin_43638968/article/details/108800361)
1. 双向数据绑定原理
	1. vue2 defineProperty()数据劫持 结合发布者、订阅者模式实现
	2. 使用了ES6的proxy
		相比于vue2.x，使用proxy的优势如下
		 - defineProperty只能监听某个属性，不能对全对象监听
		 - 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）
		 - 可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化
2. vue3中，组件可以拥有多个api
3. vue2是选项型api，vue3是组合式api（composition API）
4. 建立data数据
	1. vue2直接写在data属性中
	2. vue3：使用setup()方法，在vue中引入reactive===>使用reactive()方法声明数据为响应式数据===>使用setup()方法返回相应手机数据（在这之后，template才可以获得响应式数据）
5. 声明周期钩子--Lifestyle Hooks
```js
Vue2--------------vue3
beforeCreate  -> setup()
created       -> setup()//1.  setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method
beforeMount   -> onBeforeMount
mounted       -> onMounted
beforeUpdate  -> onBeforeUpdate
updated       -> onUpdated
beforeDestroy -> onBeforeUnmount
destroyed     -> onUnmounted
activated     -> onActivated
deactivated   -> onDeactivated
//若存在<keep-alive>，会多两个生命周期钩子
onActivated(),onDeactivated()。
```
6. 父子传参不同，setup()新特性
	1. setup 函数时，它将接受两个参数：（props、context(包含attrs、slots、emit)）
	2. setup函数是处于 生命周期函数 beforeCreate 和 Created 两个钩子函数之前的函数
	3. setup函数中不能使用this。执行 setup 时，组件实例尚未被创建（在 setup() 内部，this 不会是该活跃实例的引用，即不指向vue实例，Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined）
	4. 与模板一起使用：需要返回一个对象 (在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用)
	5. 使用渲染函数：可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态
	6. setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。但是，因为 props 是响应式的，你`不能使用 ES6 解构`，因为它会消除 prop 的响应性。如果需要解构 prop，可以通过使用 setup 函数中的`toRefs` 来完成此操作：
	7. setup函数只能是同步的不能是异步的,异步要用`Suspense`[[vue3快速上手#3.Suspense]]

### 3.nextTick
[(3条消息) Vue中的$nextTick()_star@星空的博客-CSDN博客](https://blog.csdn.net/weixin_43638968/article/details/108314554)
1. 语法：```this.$nextTick(回调函数)```
2. 作用：在下一次DOM 更新结束后，执行其指定的回调。
3. 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。
4. 替代方案：写一个不设时间的定时器
eg:修改数据后立刻得到更新后的DOM结构

### 4.打包优化
[(3条消息) vue-cli4打包最强优化（10M变300kb）_star@星空的博客-CSDN博客_vuecli 打包优化](https://blog.csdn.net/weixin_43638968/article/details/109093199)

1. 配置 proxy 跨域
#### 打包前配置
1. 去除生产环境sourceMap
```js
module.exports = {
  //去除生产环境的productionSourceMap
  productionSourceMap: false,
}
```
2. 去除console.log打印及注释
3. 使用cdn优化
4. 对资源文件进行压缩 --- 需要下载 `compression-webpack-plugin`
5. 图片下载 `npm install image-webpack-loader --save-dev
6. 只打包改变的文件
7. 公共代码抽离 `vendor`
	举例：
	项目中分别有a.js, b.js, page1.js, page2.js这四个JS文件， page1.js 和
	page2.js中同时都引用了a.js, b.js， 这时候想把a.js, b.js抽离出来合并成一个公共的js，然后在page1,page2中自动引入这个公共的js，怎么配置呢？
	第三方模块抽离
	页面中有时会引入第三方模块，比如import $ from ‘jquery’;
	page1中需要引用，page2中也需要引用，这时候就可以用vendor把jquery抽离出来，

`
### 5.业务理解，业务模块封装

### 6.密码加密
1. 使用3des进行加密
[(3条消息) 前端 Vue 请求数据使用 3DES 加密/解密_无解的菜鸟晖的博客-CSDN博客_前端3des加密](https://blog.csdn.net/weixin_41856395/article/details/119061432?spm=1001.2101.3001.6661.1&depth_1-utm_relevant_index=1)
### 反问：how to 学习？
1. 项目太简单了，业务功能模块的封装
2. 业务的理解

# 2.金山
### 1.攻击
[(3条消息) web安全及防护(XSS、CSRF、sql注入)_star@星空的博客-CSDN博客](https://blog.csdn.net/weixin_43638968/article/details/109292659)
1. xss 跨站脚本 cross-site-scripting
	1. js代码在 `<script>` 脚本中执行，在标签的事件回调中执行
	2. xss攻击：1.dom攻击 2.反射攻击 3.存储攻击  根源：输入漏洞
	3. 解决问题：cookie 防盗：http-only（模拟正常请求无法解决）==> token 代替cookie（破解协议）==> 对输入源进行安全编码（server+client，彻底解决）
2. csrf 攻击 跨站请求伪造Cross Site Request Forgery
	- XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。
	1. 原理：攻击者盗用用户身份，以用户身份发送恶意请求(利用用户的cookie，跳过验证；利用用户登录状态，在已登录网站中进行违法操作)
	2. 条件：1. 已登录a网站 2.在不关闭a的情况下，打开恶意网站b，a没做好防护
	3. 解决：1.尽量使用post，不要用get（image就可发起csrf攻击）（但仍可以使用form表单进行攻击） 2.加入验证码（csrf是伪造请求，加入验证码可以判断此请求是用户请求还是黑客） 3.验证referer（记录当前请求的来源地址）（加一个拦截器，检查referer如果referer的值不是当前网站，则拒绝请求）（！referer可能会被篡改）4. anti csrf token （目前比较完善的解决方案是加入Anti-CSRF-Token，即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。）
4. sql注入
	1. 原理：SQL注入`(SQL Injection)`，应用程序在向后台数据库传递`SQL(Structured Query Language`，结构化查询语言)时，攻击者将SQL命令插入到Web表单提交或输入域名或页面请求的查询[字符串](https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020)，最终达到欺骗服务器执行恶意的SQL命令。
	2. 方法：1.白名单验证（检查用户输入是否是符合预期的类型、长度、数值范围或者其他格式标准）、2.黑名单验证（若在用户输入中，包含明显的恶意内容则拒绝该条用户请求）3.预编译 4.限制用户不必要的访问权限
### 2.状态码
### 3.Jquery和vue区别，vue的原理
[(3条消息) jq和vue的区别_2197的博客-CSDN博客_vue和jq](https://blog.csdn.net/qq_41047322/article/details/81161461?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166773740616782428685039%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166773740616782428685039&biz_id=0&spm=1018.2226.3001.4187)
| |Jquery|Vue|
|-|------|--|
|思想|直接操作DOM|操作数据|
|操作|Query是使用选择器（$）选取DOM对象（与原生的方法比只是方便了，本质还是依赖DOM元素值）|vue通过vue对象把数据和view完全分开了。对数据的操作不会引起dom对象|
|侧重|样式操作，动画效果|数据绑定|
|适用场景|某些html5的动画页面（需要js操作样式）|复杂数据操作的后台、表单页面|


### 5.虚拟dom和uniapp，虚拟dom的作用
[(3条消息) 什么是虚拟DOM？虚拟DOM的定义和作用？_屈小康的博客-CSDN博客_虚拟dom](https://blog.csdn.net/qq_45557681/article/details/120075020?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166773866516782427457873%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166773866516782427457873&biz_id=0&spm=1018.2226.3001.4187)
[(3条消息) vue为什么要用虚拟dom机制_vue的虚拟dom详解（总结）_医脉通的博客-CSDN博客](https://blog.csdn.net/weixin_31499719/article/details/113013831?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166773866516800186566016%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166773866516800186566016&biz_id=0&spm=1018.2226.3001.4187)

1. 概念：一个用来描述真实dom结构的js对象
2. 作用：%%原生js，jq操作dom时，每操作一次就会回流%%虚拟dom可以跟踪当前dom状态，根据当前数据生成虚拟dom，当数据发生变化时，再生成一个新的dom。新旧dom保存了前后变化的状态。通过diff算法，计算出当前两个虚拟dom的茶艺，得出一个更好的替换方案。
#### diff算法
[(3条消息) vue 虚拟dom和diff算法详解_ら陈佚晨的博客-CSDN博客_vue虚拟domdiff算法](https://blog.csdn.net/weixin_42707287/article/details/113994483?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166774114916800192229233%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166774114916800192229233&biz_id=0&spm=1018.2226.3001.4187)
1. 两个虚拟dom只会再同层次之间进行比较
2. how to 判断同层？ 1. 是否再同一层 2.是否有相同的父级
![[Pasted image 20221106213016.png]]
3. 先序深度优先遍历%%当比较某个节点时，如果该节点存在子节点，那么会优先比较他的子节点，直到所有子节点全部比较完成，才会开始去比较该节点的下一个同层级节点%%
![[Pasted image 20221106213149.png]]
遍历顺序 1-9